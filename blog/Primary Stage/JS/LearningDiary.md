
网页等于Html+CSS+JavaScript

Html：网页元素内容
CSS：控制网页样式
JavaScript：操作网页内容，实现功能或者效果。

浏览器渲染机制







  Dom

  文档对象模型（DOM）是HTML和XML文档的编程接口。它给文档（结构树）
  提供了一个结构化的表述并且定义了一种方式——程序可以对结构树进行访问，以改变文档的结构，样式和内容。
 
  DOM 提供了提供了一种表述形式将文档作为一个结构化的节点组以及包含属性和方法的对象。本质上它将web页面和脚本或
  编程语言连接起来。
 
  document对象
    每个载入浏览器的HTML文档都会成为document对象。document对象包含了文档的基本信息，
  我们可以通过JavaScript对HTML页面中的所有元素进行访问、修改。
 
  document对象常用属性
  
 
  readyState属性返回当前文档的状态，共有三种状态。
 
 1. loading： 加载HTML代码阶段，尚未完成解析。
 2. interactive: 加载外部资源阶段。
 3. complete： 全部加载完成。
 
 
 
  location
 
    location属性返回只读对象，提供了当前文档的URL信息
    虽然location属性返回的对象是只读的，但是可以将URL赋值给这个属性，网页就会自动跳转到指定网址。
 
   
 Element 对象
 Element对象表示HTML元素
 
    重要属性： 
 1. nodeName： 元素标签名，还有个类似 的tagName
 2. nodeType：元素类型
 3. className：类名
 4. id：元素id
 5. children：子元素列表（HTMLCollection）
 6.childNodes：子元素列表（NodeList）
 7.firstChild：第一个子元素
 8.lastChild： 最后一个子元素
 9.nextSibling：下一个兄弟元素
 10.previousSibling：上一个兄弟元素
 11.parentNode、parentElement：父元素
 
    操作Dom元素需要先找到它 在进行操作
 
 
 
    docment.querySelector  只会选择第一个
    docment.querySelectorALL  选择多个 类数组多项 进行遍历 然后选择  
 
 elementFromPoint() 
     返回页面指定位置的元素
 
 创建元素
 
 createElement()
 用于生成HTML元素节点
 
 createTextNode()
 生成文本节点
 
 createDocumentFragment()
   DocumentFragment对象是一个存在于内存的DOM片段，但是不属于当前文档，
 常常用来生成较复杂的DOM解构，然后插入当前文档。好处在于DocumentFragment
 不属于当前文档，对它的任何改动，都不会引发网页的重新渲染，比直接修改当前文档DOM有更好的性能表现。
 
 setAttribute()用于设置元素属性
 
 修改元素
 
 appendChild（）
 在元素末尾添加元素
 
 insertBefore（）
 在某个元素之前插入元素
 
 replaceChild（）
 接受两个参数：要插入的元素和要替换的元素
 
 删除元素
 removeChild（）
 
 getAttribute（）
 用于获取元素的attribute值
 
 createAttribute（）
 生成一个新的属性对象节点，并返回它。
 createAttribute方法的参数name，是属性的名称。
 
 setAttribute（）
 用于设置元素属性
 
 removeAttribute（）
 用于删除元素属性
 
 （element.attributes 类操作数组属性  ？？？ ）
 
 
 
 innerText
 innerText是一个可写属性，返回元素内包含的文本内容，在多层次的时候会按照元素由浅到深的顺序拼接其内容。
 
 innerHTML
 innerHTML属性作用和innerText类似，但是不是返回元素的文本内容，而是返回元素的HTML结构，在写入的时候也会自动构建DOM
 
### LHS查询
> LHS查询则是试图找到变量的容器本身，从而可以对其赋值。
> 赋值操作的目标是谁（LHS）
### RHS查询
> RHS查询与简单地查找某个变量的值别无二致。（RHS并不是真正意义上的"赋值操作的右侧"，更准确的说是“非左侧”）。
> 谁是赋值操作的源头(RHS)  

作用域是根据名称查找变量的一套规则。


## ReferencenError同作用域判别失败相关，而TypeError则代表作用域判别成功了，但是对结果的操作是非法或不合理的。

### 作用域查找会在找到第一个匹配的标识符时停止。在多层的嵌套作用域中可以定义同名的标识符，这叫做“遮蔽效应”（内部的标识符“遮蔽”了外部的标识符）。抛开遮蔽效应，作用域查找始终从运行时所处的最内部作用域开始，逐级向外或者向上进行，直到遇见第一个匹配的标识符为止。  


### 词法作用域以为着作用域是由书写代码时函数声明的位置来决定的。编译的词法分析阶段基本能够知道全部标识符在哪里以及是如何声明的，从而能够预测在执行过程中如何对它们进行查找。

# 毒瘤
> eval(..)和with。不要使用这两个欺骗词法！

### 函数中的作用域

函数作用域的含义是指，属于这个函数的全部变量都可以在整个函数的范围内使用及复用（事实上在嵌套的作用域中也可以使用）。这种设计方案是非常有用的，能充分利用JavaScript变量可以根据需要改变值类型的“动态”特性。

### 隐藏内部实现

### 规避冲突
“隐藏”作用域中的变量和函数所带来的另一个好处，是可以避免同名标识符之间的冲突，两个标识符可能具有相同的名字但用途却不一样，无意间可能造成命名冲突。冲突会导致变量的值被意外覆盖。
1. 全局命名空间  

变量冲突的一个典型领子存在于全局作用中。当程序中加载了多个第三方库时，如果没有将内部私有的函数或者变量隐藏起来，就会引发冲突。  
这些库通常会在全局作用于中声名一个名字足够特别的变量，通常是一个对象。这个对象被用作库的*命名空间*，所有需要暴露给外界的功能都会成为这个对象（命名空间）的属性，而不是将自己的标识符宝库在顶级的此法作用于中。  

2. 模块管理


### 函数作用域

函数声明和函数表达式之间最重要的区别是它们的名称标识符将会绑定在何处。

### 匿名和具名

匿名函数的缺点：
>1. 匿名函数在栈追踪中不会显示出有意义的函数名，使得调试很困难。
>2. 如果没有函数名，当函数需要引用自身时只能使用已经过期的arguments.callee引用，比如在递归中。另一个函数需要引用自身的例子，是在时间触发后监听器需要解绑自身。
>3. 匿名函数省略了对于代码可读性/可理解性很重要的函数名。一个描述性的名称可以让代码不言自明。  
* 给函数表达式命名是一个最佳实践：  
![](https://github.com/zzxx9426/myPicture/blob/master/%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%91%BD%E5%90%8D.png?raw=true)

### 立即执行函数表达式

![](https://github.com/zzxx9426/myPicture/blob/master/%E7%AB%8B%E5%8D%B3%E6%89%A7%E8%A1%8C%E5%87%BD%E6%95%B0.png?raw=true)
## Undefined 
![](https://github.com/zzxx9426/myPicture/blob/master/undefined%E6%A0%87%E8%AF%86%E7%AC%A6%E6%98%AFundefined.png?raw=true)  
### IIFE还有一种变化的用途是倒置代码的运行顺序

# 块作用域

变量的声明应该距离使用的地方越近越好，并最大限度地本地化。

* try/catch
// ES6之前的环境

* let
提升是指声明会被视为存在于其所出现的作用域的整个范围内。但是使用let进行的声明不会再快作用域中进行提升。声明的代码被运行之前，声明并不“存在”。
> {  
>  console.log(bar); // ReferenceError  
>  let bar = 2;  
>}
1. 垃圾收集

2. let循环

### const
const创建块作用域变量，但其值是固定的（常量）。之后任何试图修改值的操作都会引起错误。

# 提升
包含变量和函数在内的所有声明都会在任何代码被执行前首先被处理。

* 函数优先

#作用域闭包

当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是当前词法作用域之外执行。  

### 循环和闭包

### 重返块作用域

### 模块

当函数可以记住并访问所在的词法作用域，即使函数是在当前词法作用域之外执行，这时就产生了闭包。

模块有两个主要特征：
1. 为创建内部作用域而调用了一个包装函数；
2. 包装函数的返回值必须至少包括一个对内部函数的引用，这样就会创建涵盖整个包装函数内部作用域的闭包。

## 动态作用域
词法作用域是在写代码或者说定义时确定的，而动态作用域是在运行时确定的。（this也是）词法作用域关注函数在何处声明，而动态作用域关注函数从何处调用。

## 块作用域的替代方案

* Traceur

* 隐式和显式作用域
> let-er

* 性能

## this词法

> var self = this;

* 它的作用域

this在任何情况下都不指向函数的词法作用域。在JavaScript内部，作用域确实和对象类似，可见的标识符都是他的属性。但是作用域“对象”无法通JavaScript代码访问，它存在于JavaScript*引擎*内部。  

> function foo(){  
  >var a = 2;  
  >this.bar();  
>}    

> function bar(){  
  >console.log(this.a);  
>}  

>foo();  

## this到底是什么

this是在运行时进行绑定的，并不是在编写时绑定，它的上下文取决于函数调用时的各种条件。this的绑定和函数声明的位置没有任何关系，只取决于函数的调用方式。

当一个函数被调用时，会创建一个活动记录(有时候也成为执行上下文)。这个记录会包含在哪里被调用（调用栈）、函数的调用方式、传入的参数等信息。this就是这个记录的一个属性，会在函数执行的过程中用到。  

this实际上是在函数被调用时发生的绑定，它指向什么完全取决于函数在哪里被调用。  

# this全面解析

###调用位置

调用位置：调用位置就是函数在代码中被调用的位置（而不是声明的位置）。

要分析*调用栈*（就是为了到达当前执行位置所调用的所有函数）

### 绑定规则

> 独立函数调用 

> 隐式绑定
>>  隐式丢失

### 湿式绑定

call(..)和apply(..)

1. 硬绑定

2. API调用的“上下文”

第三方库的许多函数，以及JavaScript语言和宿主环境中许多新的内置函数，都提供了一个可选的参数，通常被称为“上下文”（context），其作用和bind(..)一样，确保你的回调函数使用指定的this。  

### new绑定

* new是最后一种可以影响函数调用时this绑定行为的方法，我们称之为new绑定。

当Numner在new表达式中被调用时，它是一个构造函数：它会初始化新创建的对象。
内置对象在内的所有函数都可以用new来调用，这种函数调用被称为构造函数调用。这里有一个非常细微的区别：实际上并不存在所谓的“构造函数”，只有对于函数的“构造调用”。 

* 使用new来调用函数，或者说发生函数调用时，会自动执行下面的操作：
> 1. 创建（或者说构造）一个全新的对象。
> 2. 这个新对象会被执行[[Prototype]]连接。
> 3. 这个新对象会绑定到函数调用的this。
> 4. 如果函数没有返回其他对象，namenew表达式中的函数调用会自动返回这个新对象。


之所以要在new中使用应绑定函数，主要目的是预先设置函数的一些参数，这样在使用new进行初始化时就可以只传入其余的参数。bind(..)的功能之一就是可以把除了第一个参数(第一个参数用于绑定this)之外的其他参数都传给下层的函数(这种技术称为“部分应用”，是“柯里化”的一种)。

> function foo (p1,p2){  
> this.val = p1 + p2;  
>}  

> var bar = foo.bind(null,"p1");  

>var baz = new bar("p2");  

> baz.val; //p1p2  

### 优先级

### 判断this

1. 函数是否在new中调用（new绑定）？ 如果是的话this绑定的是新创建的对象。
  > var bar = new foo()
2. 函数是否通过call、apply（湿式绑定）或者硬绑定调用？ 如果是的话，this绑定的是指定的对象。
 > var bar = foo.call(obj2)
3. 函数是否在某个上下文对象中调用（隐式绑定）？如果是的话，this绑定的是那个上下文对象。
 > var bar = obj1.foo()
4. 如果都不是的话，使用默认绑定。如果在严格模式下，就绑定到undefined，否则绑定到全局对象。
 > var bar = foo()

 ### 被忽略的this

Object.create(null)  
Object.create(null)和{}很像，但是并不会创建Object.prototype这个委托，所以它比{}“更空”。
> function foo(a,b){  
  > console.log("a:" + a +,"b" + b);  
> }  
>  var ∅ = Object.creat(null);  

> foo.apply(∅,[2,3]); //a:2 , b:3     
> var bar = foo.bind(∅,2);  
> bar(3); // a:2,b:3  

### 间接引用

有可能创建一个函数的“间接引用”，在这种情况下，调用这个函数会应用默认绑定规则。

* 间接引用最容易在赋值时发生：

对于默认绑定来说，决定this绑定对象的并不是调用位置是否处于严格模式，而是函数体是否处于严格模式。如果函数体处于严格模式，this会被绑定到undefined，否则this会被绑定到全局对象。

### 软绑定

