# Java 基础语法

一个Java程序可以认为是一系列对象的集合，而这些对象通过调用彼此的方法来协同工作。
* 对象： 对象是类的一个实例，有状态和行为。
* 类： 类是一个模板，它描述一类对象的行为和状态。
* 方法： 方法就是行为，一个类可以有很多方法。逻辑运算、数据修改以及所有动作都是在方法中完成的。
* 实际变量： 每个对象都有独特的实际变量，对象的状态由这些实例变量的值决定。

## 基本语法 

* 大小写敏感： Java是大小敏感的，这就意味着标识符Hello和hello是不同的。
* 类名： 对于所有的类来说，类名的首字母应该大写。如果类名由若干单词组成，那么每个单词的首字母应该大写。
* 方法名: 所有的方法名都应该以小写字母开头。如果方法名含有若干单词，则后面的每个单词首字母大写。
* 原文件名： 原文件名必须和类名相同。当保存文件的时候，你应该使用类名作为文件名保存（切记Java是大小写敏感的），文件名的后缀为.Java。
* 主方法入口： 所有的Java程序有 public static void main(String []args)方法开始执行。

## Java标识符
* Java所有的组成部分都需要名字。类名、变量名以及方法名都被称为标识符。

Java标识符:

* 所有的标识符都应该以字母（A-Z或者a-z）,美元符（$）、或者下划线（ _ ）开始 

* 首字符之后可以是字母（A-Z或者a-z）,美元符（$）、下划线（ _ ）或数字的任何字符组合

* 关键字不能用作标识符  

* 标识符是大小写敏感的


## Java修饰符
Java可以使用修饰符来修饰类中方法和属性。  
主要有两类修饰符:  
* 访问控制修饰符： default，public，protected，private。
* 非访问控制修饰符： final，abstract，strictfp

## Java变量

//声明的位置划分
* 局部变量：方法或语句块内部定义的变量。  
* 成员变量： 方法外部、类的内部定义的变量。  

```
 方法体内部声明的变量（包括形参）称为局部变量：  
 方法体内部是指与方法对应的大括号内部

 在方法体外，类雷内声明的变量称为成员变量  
```


//所属的数据类型划分  
![](https://github.com/zzxx9426/S_01/blob/master/myPicture/JAVA/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%88%92%E5%88%86.png?raw=true)  

> Java中定义了4类8中基本数据类型。  
* 逻辑型-- boolean    
* 文本型-- char  
* 整数型-- byte,short,int,long  
* 浮点数型-- float，double  



* 基本数据类型 变量
```
基本数据类型转换   
boolean类型不可以转换为其他的数据类型。  
整型，字符型，浮点型的数据在混合运算中相互转换，转换时遵循以下原则：  
1. 容量晓得类型自动转换为容量大的数据类型：数据类型按容量大小排序为：  
  1.1 byte,short,char->int->long->float->double  
  1.2 byte,short,char之间不会相互转换，他们三者在计算时首先会转换为int类型  
2. 容量大的数据类型转换为容量小的数据类型时，要加上强制转换符，但可能造成精度降低或溢出：使用时要格外注意。  
3. 有多种类型的数据混合运算时，系统首先自动的将所有数据转换成容量最大的哪一种数据类型，然后再进行计算。  
4. 实数常量（如：1.2）默认为double。  
5. 整数常量（如：123）默认为int。  

```
* 引用数据类型 变量 

从本质上来将，变量其实是内存里面的一小块区域，一个程序在运行的时候，实际上是位于内存里面，然后才开始运行。一个.exe文件存放在硬盘上无法运行的，在硬盘上看到的.exe文件无非就是一个文件而已，当我们双击这个.exe文件时，运行起来的时候实际上是整个.exe文件被放在了内存里面，然后操作系统找到main方法，也就是程序的入口，然后就开始执行了，执行的过程中，会不断地在内存里面分配一些区域，变量在内存里面就是一小块区域，变量有两个概念，一个是变量的名字，另一个是变量的值，即这一小块区域是有名字的，里面装着一个值，因此以后要想访问这小块区域里面的内容就可以根据这小块区域的名字来访问了。因此，变量的本质就是一小块内存区域。就变量来说，该内存里面分配多大的存储空间呢？不同的变量类型分配不同大小的存储空间，每一个变量都是属于特定的数据类型的，声明成不同的数据类型，他就在内存里面分配不同的存储空间。  
变量的作用于：变量的作用域只在“{}”有效，出了这个“{}”就没有作用了。  



## Java数组

数组是储存在堆上的对象，可以保存多个同类型变量。

## Java枚举
例：  

![](https://github.com/zzxx9426/S_01/blob/master/myPicture/other/Java%E6%9E%9A%E4%B8%BE.png?raw=true)  
枚举可以单独声明或者声明在类里面。方法、变量、构造函数也可以在枚举中定义。

## Java关键字
这些保留字不能用于常量、变量、和任何标识符的名称。
![](https://github.com/zzxx9426/S_01/blob/master/myPicture/other/Java%20%E5%85%B3%E9%94%AE%E5%AD%97.png?raw=true)

## Java注释
单行 //  
多行 /*  */
Java空白行或者有注释的行，Java编辑器都会忽视掉。

## 继承

在Java中，一个类可以由其他类派生，如果你要创建一个类，而且已经存在一个类具有你所需要的属性或方法，那么你可以将新创建的类继承该类。  
利用继承的方法，可以重用已存在类的方法和属性，而不用重写这些代码。被继承的类成为超类（super class），派生类成为子类（subclass）。

## 接口

在Java中，接口可理解为对详见相互通信的协议。接口在继承中扮演者很重要的角色。  
接口只定义派生要用到的方法，但是方法的具体实现完全取决于派生类。

## Java对象和类

Java作为一种面向对象语言。  
* 多态、继承、封装、抽象、类、对象、实例、方法、重载。

* 对象： 
对象是类的一个实例，有状态和行为。  
* 类：  
类是一个模板，它描述一类对象的行为和状态。

* Java中的类
类可以看成是创建Java对象的模板。
一个类可以包含以下类型变量： 
> 局部变量： 在方法、构造方法或者语句块中定义的变量被称为局部变量。变量声明和初始化都是在方法中，方法结束后，变量就会自动销毁。
> 成员变量： 成员变量是定义在类中，方法体之外的变量。这种变量在创建对象的时候实例化。成员变量可以被类中方法，构造方法和特定类的语句块访问。
> 类变量： 类变量也声明在类中，方法体之外，但必须声明为static类型  。

* 构造方法
每个类都有构造方法。如果没有显式地为类定义构造方法，Java编译器将会为该类提供一个默认构造方法。  
在创建一个对象的时候，至少要调用一个构造方法。构造方法的名称必须与类同名，一个类可以有多个构造方法。

* 创建对象

对象是根据类创建的。在Java中，使用关键字new来创建一个新的对象。创建对象需要以下三步：
* 声明： 声明一个对象，包括对象名称和对象类型。  
* 实例化 ： 使用关键字new来创建一个对象。
* 初始化： 使用new创建对象时，会调用构造方法初始化对象。

## 访问实例变量和方法
通过已创建的对象来访问成员变量和成员方法。

## 源文件声明规则

当在一个源文件中定义多个类，并且还有import语句和package语句时，要特别注意以下规则。
* 一个原文件中只能有一个public类
* 一个源文件可以有多个非pubilc类
* 源文件的名称应该和public类的类名保持一致。
* 如果一个类定义在某个包中，那么package语句应该在源文件的首行。
* 如果源文件包含import语句，那么应该放在package语句和类定义之间。如果没有package语句，那么import语句应该在源文件中最前面。
* import语句和package语句对源文件中定义的所有类都有效。在同一源文件中，不能给不同的类不同的包声明。  
类有若干种访问级别，并且类也分不同的类型：抽象类和final类等。  
Java还有一些特殊的类，如：内部类、匿名类。

## Java包

包主要用来对类和接口进行分类。当开发Java程序时，可能编写成百上千的类，因此很有必要对类和接口进行分类。

## import语句

在Java中，如果给出一个完整的限定名，包括包名、类名，那么Java编译器就可以很容易地定位到源代码或者类。Import语句就是用来提供一个合理的路径，使得编译器可以找到某个类。
例：
 > import java.io *；


## Java基础数据类型

变量就是申请内存来储存值。也就是说，当创见变量的时候，需要在内存中申请空间。  
内存管理系统根据变量的类型为变量分配储存空间，分配的空间只能用来储存该类型数据。   

因此，通过定义不同类型的变量，可以在内存中储存整数、小数或者字符。  
Java的两大数据类型：  
*  内置数据类型
*  引用数据类型

## 内置数据类型

Java语言提供了八种基本类型。六中数字类型（四个整数型，两个浮点型），一种字符类型，还有一种布尔型。  

byte：    

byte 数据类型是8位、有符号的，以二进制补码表示的整数；  
最小值是 -128（-2^7）；  
最大值是 127（2^7-1）；  
默认值是 0；  
byte 类型用在大型数组中节约空间，主要代替整数，因为 byte 变量占用的空间只有 int 类型的四分之一；  
例子：byte a = 100，byte b = -50。  

short：  

short 数据类型是 16 位、有符号的以二进制补码表示的整数  
最小值是 -32768（-2^15）；  
最大值是 32767（2^15 - 1）；  
Short 数据类型也可以像 byte 那样节省空间。一个short变量是int型变量所占空间的二分之一；  
默认值是 0；  
例子：short s = 1000，short r = -20000。  

int：  

int 数据类型是32位、有符号的以二进制补码表示的整数；  
最小值是 -2,147,483,648（-2^31）；  
最大值是 2,147,483,647（2^31 - 1）；  
一般地整型变量默认为 int 类型；  
默认值是 0 ；  
例子：int a = 100000, int b = -200000。  
long：  

long 数据类型是 64 位、有符号的以二进制补码表示的整数；  
最小值是 -9,223,372,036,854,775,808（-2^63）；  
最大值是 9,223,372,036,854,775,807（2^63 -1）；  
这种类型主要使用在需要比较大整数的系统上；  
默认值是 0L；  
例子： long a = 100000L，Long b = -200000L。  
"L"理论上不分大小写，但是若写成"l"容易与数字"1"混淆，不容易分辩。所以最好大写。  

float：  

float 数据类型是单精度、32位、符合IEEE 754标准的浮点数；  
float 在储存大型浮点数组的时候可节省内存空间；  
默认值是 0.0f；  
浮点数不能用来表示精确的值，如货币；  
例子：float f1 = 234.5f。  

double：  

double 数据类型是双精度、64 位、符合IEEE 754标准的浮点数；  
浮点数的默认类型为double类型；  
double类型同样不能表示精确的值，如货币；  
默认值是 0.0d；  
例子：double d1 = 123.4。  

boolean：  

boolean数据类型表示一位的信息；  
只有两个取值：true 和 false；  
这种类型只作为一种标志来记录 true/false 情况；  
默认值是 false；  
例子：boolean one = true。  

char：  

char类型是一个单一的 16 位 Unicode 字符；  
最小值是 \u0000（即为0）；  
最大值是 \uffff（即为65,535）；  
char 数据类型可以储存任何字符；  
例子：char letter = 'A';。  


## 引用类型

* 在Java中，引用类型的变量非常类似于C/C++的指针。引用类型指向一个对象，指向对象的变量是引用变量。这些变量在声明时被指定为一个特定的类型。变量一旦声明后，类型就不能被改变了。
* 对象、数组都是引用数据类型。
* 所有引用类型的默认值都是null。
* 一个引用变量可以用来引用任何与之兼容的类型。

## Java常量

常量在程序运行时是不能被修改的。  
在Java中使用final关键字来修饰常量，声明方式和变量类似。
虽然常量名也可以用小写，但为了便于识别，通常使用大写字母表示常量。  
字面量可以赋给任何内置类型的变量。  
byte、int、long和shot都可以用十进制、16进制以及8进制的方式来表示。  
当使用常量的时候，前缀0表示8进制，而前缀0x代表16进制。  
Java的字符串常量也是包含在两个引号之间的字符序列。  
字符串常量和字符常量都可以包含任何Unicode字符。  
Java语言特殊转义符：
![](https://github.com/zzxx9426/S_01/blob/master/myPicture/other/Java%20%E7%89%B9%E6%AE%8A%E8%BD%AC%E4%B9%89%E5%AD%97%E7%AC%A6.png?raw=true)  

## 自动类型转换 
整型、实型（常量）、字符型数据可以混合运算。运算中，不同类型的数据先转化为同一类型，然后进行运算。  
转换从低级到高级。  
![](https://github.com/zzxx9426/S_01/blob/master/myPicture/other/%E8%87%AA%E5%8A%A8%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2.png?raw=true)

数据类型转换必须满足如下规则：  
* 1. 不能对bollean类型进行类型转换。
* 2. 不能把对象类型转换成不相关类的对象。
* 3. 在把容量大的类型转换为容量小的类型时必须使用强制类型转换。
* 4. 转换过程中可能导致溢出或损失精度。
* 5. 浮点数到整数的转换是通过舍弃小数得到，而不是四舍五入。

## 自动类型转换 

必须满足转换前的数据类型的位数要低于转换后的数据类型。  

## 强制类型转换  
* 1. 条件是转换的数据类型必须是兼容的。
* 2. 格式：(type)value type是要强制类型转换后的数据类型

## 隐含强制类型转换

* 1. 整数的默认类型是int。
* 2. 浮点型不存在这种情况，因为在定义float类型时必须在数字后面跟上F或者f。
 
 ## Java变量类型
 在Java语言中，所有的变量在使用前必须声明。  
 > type identifier [ = value][,identifier [= value] ...] ;  
 type为Java数据类型。identifier是变量名。可以使用都好隔开来声明多个同类型变量。  
 Java语言支持的变量类型有：  
 * 类变量： 独立于方法之外的变量，用static修饰。
 * 实例变量： 独立于方法之外的变量，不过没有static修饰。
 * 局部变量： 类的方法中的变量。

 ## Java局部变量
 * 局部变量声明在方法、构造方法或者语句块中；
 * 局部变量在方法、构造方法、或者语句块被执行的时候创建，当它们执行完成后，变量将会被销毁；
 * 访问修饰符不能用于局部变量；
 * 局部变量只在声明它的方法、构造方法或者语句块中可见；
 * 局部变量是在栈上分配的。
 * 局部变量没有默认值，所以局部变量被声明后，必须经过初始化，才可以使用。

## 实例变量

* 实例变量声明在一个类中，但在方法、构造方法和语句块之外；
* 当一个对象被实例化之后，每个实例变量的值就跟着确定；
* 实例变量在对象创建的时候创建，在对象被销毁的时候销毁；
* 实例变量的值应该至少被一个方法、构造方法或者语句块引用，是的外部能够通过这些方式获得实例变量信息；
* 实例变量可以声明在使用前或者使用后；
* 访问修饰符可以修饰实例变量；
* 实例变量对于类中的方法、构造方法或者语句块是可见的。一般情况下应该把实例变量设为私有。通过使用访问修饰符可以使实例变量对子类可见；
* 实例变量具有默认值。数值型变量的默认值是0，布尔型变量的默认值是false，引用类型变量的默认值是null。变量的值可以在声明使制定，也可以在构造方法中制定；
* 实例变量可以直接通过变量名访问。但在静态方法以及其他类中，就应该使用完全限定名：ObejectReference.VariableName。

## 类变量（静态变量）
* 类变量也称为静态变量，在类中以static关键字声明，但必须在方法构造方法和语句块之外。
* 无论一个类创建了多少个对象，类只拥有类变量的一份拷贝。
* 静态变量除了被声明为常量外很少使用。常量是指声明为public/private，final和static类型的变量。常量初始化后不可改变。
* 静态变量储存在静态储存区。经常被声明为常量，很少单独使用static声明变量。
* 静态变量在第一次被访问时创建，在程序结束时销毁。
* 与实例变量具有相似的可见性。但为了对类的使用者可见，大多数静态变量声明为public类型。
* 默认值和实例变量相似。数值型变量默认值是0，布尔型默认值是false，引用类型默认值是null。变量的值可以在声明的时候指定，也可以在构造方法中指定。此外，静态变量可以在静态语句块中初始化。
* 静态变量可以通过：ClassName.VariableName的方式访问。
* 类变量被声明为Public static final类型时，类变量名称一般建议使用大写字母。如果静态变量不是public和final类型，其命名方式与实例变量以及局部变量的命名方式一致。

## Java修饰符
Java语言提供了很多修饰符，主要分为以下两类：
* 访问能修饰符
* 非访问修饰符
修饰符用来定义类、方法或者变量，通常放在语句的最前端。

## 访问控制修饰符
Java中，可以使用访问控制符来保护对类、变量、方法和构造方法的访问。Java支持4种不同的访问权限。
* default（即缺省，什么也不写）：在同一包内可见，不适用任何修饰符。使用对象：类、接口、变量、方法。
* private：在同一类内可见。使用对象：变量、方法。 *注意：不能修饰类（外部类）*
* public：对所有类课件。使用对象：类、接口、变量、方法。
* protected：对同一包内的类和所有子类课件。使用对象：变量、方法。*注意：不能修饰类（外部类）*。

## 默认访问能修饰符-不使用任何关键字
使用默认访问能修饰符声明的变量和方法，对同一个包内的类是可见的。接口里的变量都隐式声明为public static final，而接口里的方法默认情况下访问权限为public。  
变量和方法的声明可以不使用任何修饰符。  

## 私有访问修饰符-private
私有访问修饰符是最严格的访问级别，所以被声明为private的方法、变量和构造法只能被所属类访问，并且类和接口不能声明为private。声明为私有访问类型的变量只能通过类中公共的getter方法被外部类访问。  
Private访问修饰符的使用主要用来隐藏类的实现细节和保护类的数据。

##公有访问修饰符-public
被声明为public的类、方法、构造方法和接口能够被任何其他类访问。  
如果几个相互访问的public类分红不在不同的保重，则需要导入相应pubic类所在的包。由于类的继承性，类所有的公有方法和变量都能被其子类继承。
Java程序的main（）方法必须设置成公有的，否则，Java解释器将不能运行该类。  

## 受保护的访问修饰符-protected  
protected需要以下两个点来分析说明：
* 子类和基类在同一包中：被声明为protected的变量、方法和构造器能被同一包中的任何其他类访问；
* 子类和基类不在同一包中：那么在子类中，子类实例可以访问其从基类继承而来的protected方法，而不能访问基类实例的protected方法。  
protected访问修饰符可以修饰类及其方法和成员变量，但是接口及接口的成员变量和成员方法不能声明为protected。  
> 子类能访问protected修饰符声明的方法和变量，这样就能保护不相关的类使用这些方法和变量。  

## 访问控制和继承
继承的规则：  
* 父类中声明为public的方法在子类中也必须为public。
* 父类中声明为protected的方法在子类中要么声明为protected，要么声明为public，不能声明为private。
* 父类中声明为private的方法，不能够被继承。

## 非访问修饰符  
为了实现一些其他的功能，Java也提供了许多非访问修饰符。  
static修饰符，用来修饰类方法和类变量。
final修饰符，用来修饰类、方法和变量，final修饰类不能够被继承，修饰的方法不能被继承类重新定义，修饰的变量为常量，是不可修改的。  
abstract秀地府，用来创建抽象类和抽象方法。  
synchronized和volatile修饰符，主要用于线程的编程。  
### static修饰符
* 静态变量：  
static关键字用来声明独立于对象的静态变量，无论一个类实例化多少对下那个，它的静态变量只有一份拷贝。静态变量也被称为类变量。局部变量不能被声明为static变量。

* 静态方法：    
static关键字用来声明独立于对象的静态方法。静态方法不能使用类的非静态变量。静态方法从参数列表得到数据，然后计算这些数据。  
对类变量和方法的访问可以直接使用classname.variablename和classname.methodname的方式访问。  

### final修饰符
final变量：  
final变量能被显式地初始化并且只能初始化一次。被声明为final的对象不能指向不同的对象。但是final对象里的数据可以被改变。也就是说final对象的引用不能改变，但是里面的值可以改变。  
final修饰符童话村那个和static修饰符一起使用来创建类常量。  
final成员变量必须直接在声明时候初始化，或者在构造方法里面初始化！！  
 
#### final方法
类中的final方法可以被子类继承，但是不能被子类修改。  
声明final方法的主要目的是防止该方法的内容被修改。  
#### final类
final类不能被继承，没有类能够继承final类的任何特性。


### abstract修饰符
抽象类：  
抽象类不能用来实例化对象，声明抽象类的唯一目的是为了将来对该类进行扩充。  
一个类不能同时被abstract和final修饰。如果一个类办函抽象方法，那么该类一定要声明为抽象类，苟泽将出现变异错误。  
抽象类可以包含抽象方法和非抽象方法。    
#### 抽象方法 
抽象方法是一种没有任何实现的方法，该方法的具体实现由子类提供。  
抽象方法不能被声明称final和static。  
任何继承抽象类的子类必须实现父类的所有抽象方法，除非该子类也是抽象类。  
如果一个类包含若干个抽象方法，那么该类必须声明为抽象类。抽象类不包含抽象方法。   
抽象方法的声明以分好结尾。   

### synchronized修饰符 
synchronized关键字声明的方法同一时间只能被一个线程访问。synchoronized修饰符可以应用于四个访问修饰符。  

### transient修饰符
序列化的对象包含被transient修饰的实例变量时，java虚拟机（JVM）跳过该特定的变量。  
该修饰符包含在定义变量的语句中，用来预处理类和变量的数据类型。  
### volatile修饰符
volatile修饰的成员变量在每次被线程访问时，都强制从共享内存中重新读取该成员变量的值。而且，当成员变量发生变化时，会强制线程将变化值回写到共享内存。这样在任何时刻，两个不同的线程总是看到某个成员变量的同一个值。  
一个volatile对象引用可能是null。  
通常情况下，在一个线程调用run（）方法，在另一个线程调用stop（）方法。

### Java运算符
  计算机最基本用途之一就是执行数学运算，作为一门计算机语言，Java也提供了一套丰富的运算符来操纵变量。  
* 算数运算符
* 关系运算符
* 位运算符
* 逻辑运算符
* 复制运算符
* 其他运算符

### 算术运算符
算术运算符在数学表达式中，它们的作用和在数学中的作用一样。  
![](https://github.com/zzxx9426/S_01/blob/master/myPicture/other/%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%AC%A6.png?raw=true)

### 自增自检运算符
1. 自增（++）自减（--） 运算符是一种特殊的算术运算符，在算术运算符中需要两个操作数来进行运算，而自增自减运算符是一个操作符。
2. 前缀自增自减法（++a，--a）：先进行自增或者自减运算，再进行表达式运算。
3. 后缀自增自减法（a++, a--）：先进行表达式运算，再进行自增或者自减运算。  
### 关系运算符  
![](https://github.com/zzxx9426/S_01/blob/master/myPicture/other/%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6.png?raw=true)
  
### 位运算符
Java定义了位运算符，应用于整数类型（int），长整型（long），短整型（short），字符型（char），和字节型（byte）等类型。  
位运算符作用在所有的位上，并且按位运算。  
![](https://github.com/zzxx9426/S_01/blob/master/myPicture/other/%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6.png?raw=true)      
###逻辑运算符  
![](https://github.com/zzxx9426/S_01/blob/master/myPicture/other/%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6.png?raw=true)   

### 短路逻辑运算符  
当使用与逻辑运算符时，在两个操作数都为true时，结果才为true，但是当得到第一个操作为false时，其结果就必定是false，这时候就不会再判断第二个操作了。  
![](https://github.com/zzxx9426/S_01/blob/master/myPicture/other/%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6.png?raw=true)  

### 赋值运算符  
![](https://github.com/zzxx9426/S_01/blob/master/myPicture/other/%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6.png?raw=true)    


### 条件运算符
条件运算符也被成为三元运算符。该运算符有3个操作数，并且需要判断布尔表达式的值。该运算符的主要是决定哪个值应该赋值给变量。
variable x = (expression) ? value if true : valur if false
### instanceof运算符
该运算符用于操作对象实例，检查该对象是否是一个特定类型（类类型或接口类型）。  
(Object reference variable) instanceof (class/interface type)

### Java运算符优先级
![](https://github.com/zzxx9426/S_01/blob/master/myPicture/other/%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7%20.png?raw=true)  





