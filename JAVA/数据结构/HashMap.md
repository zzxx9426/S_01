## HashMap是什么？  

HashMap基于哈希表的Map接口的实现。此实现提供所有可选的映射操作，并允许使用null值和null键。（除了不同步和允许使用null外，HashMap类与Hashtable大致相同）此类不保证映射的顺序，特别是它不保证该顺序恒久不变。  


### 注意：  
HashMap不是安全线程，如果想要线程安全的HashMap，可以通过Collections类的静态方法synchronizedMap获得线程安全的HashMap。
```
Map map = Collections.syncronizedMap(new HashMap());
```

* 一个hash函数作用在不同的key时，所得到的value能够均匀的分布在hash表中，尽可能减少hash冲突。  
   * 常见的hash函数的构造方法有：  
     * 指定定扯发
     * 数字分析法
     * 平方去中法
     * 折叠法
     * 除留余数法
     * 随机数法

* hash冲突时不能完全避免的，那么我们要考虑的还有就是当产生哈希冲突的时候，我们如何来解决。常见的hash冲突的解决方法有：  
   * 开放定扯法
   * 链地址法
   * 再哈希法  


###  HashMap的数据结构
采用哈希表的初衷就是对连续的存储结构数组和非连续的存储结构链表，在数据的增删改查等操作上进行折中。  

HashMap的底层主要是基于数组和链表来实现的，它之所以有相当的查询速度主要是因为它是通过计算散列码来决定存储的位置。HashMap中主要是通过key的hashCode来计算hash值的，只要hashCode相同，计算出来的hash值就一样。如果存储的对象对多了，就有可能不同的对象所算出来的hash值是相同的，这就是出现了所谓的hash冲突。HashMap底层是通过链表来解决hash冲突的。  

### HashMap源码分析  
* 1. 关键属性   
transient Entry[] table;// 存储元素的实体数组。    
transient int size; // 存放元素的个数  
int threshold;// 临界值 当实际大小超过临界值时，会进行扩容threshold = 加载因子*容量。  
final float loadFactor;// 加载因子  
transient int modCount;// 被修改的次数  
其中loadFactor加载银子是表示Hash表中元素的填满的程度。  
若： 加载因子越大，填满的元素越多，好处是，空间利用率高，但是，冲突的机会加大了。链表长度会越来越长，查找效率降低。  

反之，加载因子越小，填满的元素越少，好处是：冲突的机会减小了，但是，空间浪费多了。表中的数据将过于稀疏（很多空间还没用，就开始扩容了）    

冲突的机会越大，则查找的成本越高。  

因此，必须在“冲突的机会”与"空间利用率"之间寻找一种平衡与折中。这种平衡与折中本质上是数据结构中有名的“时-空”矛盾的平衡与折中。  


哈希表的初衷就是对连续的存储结构数组和非连续的存储结构链表，在数据的增删改查等操作。 

**增**
* HashMap的创建跟其他类的创建以及ArrayList的方法创建时一样的都是通过new一个对象的方式创建。  
  * .put（key,value）；方法既是      追加也是更改。如果list中没有该元素那么追加这个要素，如果list中已经含有这个元素那么就更改这个元素的值(因为key相同所以更改的都是vlaue的内容)   
****
**改**
* .put的方法就是添加也是修改。它没有update方法，所以当要修改一个元素的时候首先一定要判断这个元素是否存在于hashmap中然后再修改。没有改元素那么put就实现了添加的作用。  

****
**删**
* .remove()方法，可以直接删除要删除的元素。  

****

